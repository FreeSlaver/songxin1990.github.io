---
layout: page

title: Java面试题-JVM调优
category: interview-question-experience
categoryStr: 面试
tags: [interview]
keywords:
description:
---

## 网络参考资料
JVM调优不是常规手段，性能问题一般第一选择是优化程序，最后的选择才是进行JVM调优。JVM调优应该是Java性能优化的最后一颗子弹。


## 3、JVM调优的目标
吞吐量、延迟、内存占用三者类似CAP，构成了一个不可能三角，只能选择其中两个进行调优，不可三者兼得。

延迟：GC低停顿和GC低频率；
低内存占用；
高吞吐量;
选择了其中两个，必然会会以牺牲另一个为代价。

下面展示了一些JVM调优的量化目标参考实例：

Heap 内存使用率 <= 70%;
Old generation内存使用率<= 70%;
avgpause <= 1秒;
Full gc 次数0 或 avg pause interval >= 24小时 ;
注意：不同应用的JVM调优量化目标是不一样的
## 问：做过JVM调优么？怎么做的？

## 何时进行JVM调优
遇到以下情况，就需要考虑进行JVM调优了：
* Heap内存（老年代）持续上涨达到设置的最大内存值；
* Full GC 次数频繁；
* GC 停顿时间过长（超过1秒）；
* 应用出现OutOfMemory 等内存异常；
* 应用中有使用本地缓存且占用大量内存空间；
* 系统吞吐量与响应性能不高或下降。


## 为什么不建议JVM调优？
* 大多数的Java应用不需要进行JVM优化；
* 大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；
* 上线之前，应先考虑将机器的JVM参数设置到最优；
* 减少创建对象的数量（代码层面）；
* 减少使用全局变量和大对象（代码层面）；
* 优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；
* 分析GC情况优化代码比优化JVM参数更好（代码层面）

通常来说，我们的 JVM 参数配置大多还是会遵循 JVM 官方的建议，例如：

-XX:NewRatio=2，年轻代:老年代=1:2

-XX:SurvivorRatio=8，eden:survivor=8:1

堆内存设置为物理内存的3/4左右

## 4、JVM调优的步骤
一般情况下，JVM调优可通过以下步骤进行：

分析系统系统运行情况：分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；
确定JVM调优量化目标；
确定JVM调优参数（根据历史JVM参数来调整）；
依次确定调优内存、延迟、吞吐量等指标；
对比观察调优前后的差异；
不断的分析和调整，直到找到合适的JVM参数配置；
找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。
以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行。
https://ask.qcloudimg.com/http-save/yehe-7565276/2ndk8iplib.png



## JVM调优目的
低延时，也就是GC停顿的时间尽可能短
高吞吐量，也即GC占用的整个时间尽可能短

## JVM调优实战案例
这么多年我一共遇到过两次因为JVM参数引发的问题：

一次是某公司的超大型Java程序，导致PermGen OutOfMemoryError，那是JDK 1.6平台，原因很简单，编写的Java类数量太多了，撑爆了默认的128M的PermGen。解决方法也很简单，改成更大的512M（参数叫啥已经忘了，因为新版JVM没有PermGen限制了）。但是根本问题不是出在JVM，而是代码太垃圾，Java类的数量超多造成的。

另一次是因为TPS超高引起内存不足崩溃，但实际上内存有32G非常大，分配给JVM有30G，不可能用完。现实情况是EC2直接被干掉连日志都看不到了。如果手动把TPS降下来（每次sleep 1ms），就能以一定概率成功启动。后咨询AWS技术支持发现，原来是Kafka这货为了提高速度，用了大量的堆外内存结果在高TPS下爆了。解决方法也很简单，把JVM内存限制在系统内存的一半，给操作系统留出足够的内存。这次根本问题是代码性能太高但错误地设定了XMS和XMX造成的。