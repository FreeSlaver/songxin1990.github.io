---
layout: page
title:  面试官：你们系统用户量多少？最大并发数多少？最大每秒QPS多少？怎么回答？
category: interview-question-experience
tags: [QPS,并发量]
keywords:
description:
published:  true
---

艹他妈的，实话说，一个个改需求，享受996福报累的狗一样的，把任务及时做完能交差就够呛了，谁鸡巴有空去查这些东西啊。  
很多码畜连个功能需求都搞不定，能写十几个bug，最后还要老子给他们擦屁股。

这狗日的面试官就喜欢搞这些玩意，我就反过来问问你：你们公司用户量多少？最大并发量多少？每秒QPS多少？  
我估计他自己都是一脸懵比。一顿操作猛如虎，一看此人二百五，面试造航母，入职撬螺母。


以我在中集电商的工作项目经历来看，总共有3w多台柜子，就按照3万来算，那么快递柜连接服务器的心跳的QPS，就是3万每秒，  
因为只是简单的发送了一个心跳，就类似快递柜发送一个Ping字符串到服务器端，服务器端返回一个Pong字符串到客户端，
所以带宽不成为问题，以常用的4核8G来为例，一台机器上一般部署了Nginx，Java服务实例，Redis，MySQL，Kafka集群，ES集群等，
现在假设全部部署在一台机器上，按照默认配置，那么支持的并发量，每秒QPS是多少了？？

### Nginx支持的最大连接数多少？
单机Nginx QPS可达到30W，Redis单机8W
### Java服务实例，以Spring MVC为例，支持的最大连接数多少？

### MySQL支持的最大连接数多少？
show variables like '%max_connections%';
151//5.7默认就是151个

MySQL 单机的 QPS 为 大概在 4k 左右。
## Tomcat 
单机 Tomcat 的 QPS 在 2w 左右。
Tomcat 配置 APR 为 连接器的话，QPS 可以达到 3w 左右

不同的框架对并发量的支持会有所不同，具体取决于框架的设计、实现和配置等因素。以下是一些常见框架的并发量范围：


Servlet 容器（如 Tomcat、Jetty）：通常支持数千到数万的并发连接。

Spring 框架：Spring 本身不直接处理并发，但是它可以与支持高并发的技术如 Netty、Vert.x 等集成，因此具体并发量取决于所使用的技术。

Netty：Netty 是一个高性能、异步的网络编程框架，可以支持数万并发连接。

Akka：Akka 是一个基于 Actor 模型的并发框架，可以支持数百万的并发连接。

Redis：Redis 是一个内存数据库，可以支持数十万到数百万的并发连接。



看巴巴怎么从头开始虚拟，构造一个完美的回答。  
首先Google下一般公司买什么配置的云服务器比较合适，一般公司大多就搞一台机器，能省钱就省，出了问题，重启大法。  
好吧，没找到，全是推销云主机的，以最低端的2核2g的云服务器来看的话，



2C4G机器单机一般1000QPS。

8C8G机器单机可承受7000QPS。

写在后面

具体多少QPS跟业务强相关，只读接口读缓存，将压力给到缓存单机3000+没问题，写请求1000+也正常，也复杂些可能也就几百+QPS。

所以QPS和业务场景和设计相关性很大，比如可以通过浏览器本地缓存，用缓存做热点数据查询，写事务MQ异步处理等方式提升QPS。
首先是无状态前端机器不足以承载请求流量，需要进行水平扩展，一般QPS是千级。 然后是关系型数据库无法承载读取或写入峰值，需要数据库横向扩展或引入nosql，一般是千到万级。 之后是单机nosql无法承载，需要nosql横向扩展，一般是十万到百万QPS。 最后是难以单纯横向扩展nosql，比如微博就引入多级缓存架构，这种架构一般可以应对百万到千万对nosql的访问QPS。 当然面向用户的接口请求一般到不了这个量级，QPS递增大多是由于读放大造成的压力，单也属于高并发架构考虑的范畴。


所以这里直接告诉大家一个经验值，即使说咱们如果部署的是一个4核8G的机器，
然后spring boot内嵌的tomcat默认开了200个线程来处理请求，
接着每个请求都要读写多次数据库，那么此时，大致来说你的一台机器可以抗大概500~1000这个并发量， 具体多少得看你的接口复杂度。

所以**业务系统的一次接口请求可能会导致数据库有多次请求** ，也正因为这样，所以此时可能你的数据库并发压力会到几千的样子。

通常会是8核16G。那么8核16G的数据库每秒大概可以抗多少并发压力？大体上来说，在几千这个数量级。  
因为这个具体能抗多少并发也得看**你数据库里的数据量 以及你的SQL语句的复杂度，** 所以一般来说8核16G的机器，大概也就是抗到每秒几千并发就差不多了

不合理，一般来说 QPS200 CPU70%，大概率存在大量线程切换，检查一下几个地方
1. spring boot 线程数是不是满了，自带 tomcat 默认 200 ，如果满了说明后端处理太慢了。
2. 看一下你的 mysql 线程池大小多少，是不是默认的 8 。
3. 看一下你的 mysql 每条查询到底多少毫秒，开一下 druid 这类链接池监控就行，看看是不是 mysql 查询存在瓶颈。
4. 开 jprofile 之类的工具，在线看一下 CPU 事件消耗在哪里，大概是 mysql 引起的线程等待

可能的处理方案：
1. 如果 mysql 存在瓶颈，建议把 spring boot 的线程数调低，高了毫无意义。
2. mysql 查询快，你可以缩小你的 mysql 线程池数量，反之扩大。
3. redis 确保用异步驱动不要用 jedis
4. 客户端是离散的还是集中的，如果固定一些极其请求你这个服务，http keep-alive 记得开。

最后，你这类服务如果要用 java ，不建议 spring boot 。至少不要用同步的 jdbc ，该用异步数据库驱动+异步 redis 驱动+少线程（一般都是基于 netty ）的 web 容器。比如干脆 vert.x
当然这个涉及到技术选型，可能你说了不算。还有一个方案你可以参考，就是把 spring boot 不要自己接 http 请求，spring boot 就启动一个 netty 就好了，netty 负责 http 编解码和 vo 转换部分，netty 和 spring boot 通过 applicationContext 交互。至少保证线程数不太多，CPU 也不会飙多高，你专心调整的 mysql 线程池到一个合理数量。
最后，CPU 飙高说来说起大概率还是线程太多的问题～～