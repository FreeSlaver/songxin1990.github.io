---
layout: page
title: 分布式事务
category: distribute
categoryStr: 分布式
tags:
keywords:
description:
---

可以这么来想：张三向李斯的账户转账1000块，但是张三的账户的表部署在机器A上，李斯的账户表部署在机器B上，如何保证ACID？

如何在一个MySQL实例中，我们只需要将这整个操作包含到一个事务中，即可。
```java
try{
    conn.setAutoCommit(false);
    String sql = "update t_account set balance -= 1000 where id = '张三'";
    String sql2 = "update t_account set balance += 1000 where id = '李斯'";
    conn.execute(sql);
    conn.execute(sql2);
    conn.commit();  
}catch(Exeception e){
    conn.rollback();    
}finally{
    conn.close();    
}
```
伪代码大概就是这样。

现在这个账户表分布在两台机器上，（可能是分库分表，可能是两个系统，可能新旧系统同步），怎么保证acid？
## 方法1
最傻最简单，最容易想到的就是，先将张三的账户扣款1000块，然后锁住这条记录，
再将李斯的账户加1000块，如果成功，释放张三这条数据上的锁，事务完成；
如果失败，不停重试，重试三次后，还是失败，回滚张三的事务，事务完成，然后人工介入看看为撒一直失败。

这个方法简单高效也容易理解，但问题是：1.张三账户的锁一直无法释放，这期间甚至无法查询（因为不知道转账是否成功，只能锁着）。
2.如果这个账号高频的进行转账操作，会整个的拖累系统，降低系统的并发度，性能
3.等待时间过长，张三账户这条记录的锁必须等待李斯的操作成功或者失败后才能释放。

## 方法2
张三和李斯同时进行操作，同时进行加锁，然后将操作结果和加锁结果交给一个仲裁者，如果都成功，那么仲裁者让双方都提交事务，
如果张三成功，李斯失败，或者李斯成功，张三失败，这时仲裁者可以让其中一方进行重试，或者另一方回滚。

1.如果直接让成功的一方回滚的话，事务的acid保证了，但是这样显然是对网络资源，计算资源等的浪费。
2.如果让失败的一方重试的话，同样的会遇到和方法1的问题，就是需要在重试这段时间持有成功一方的锁，大大降低系统的并发度和用户体验度。

所以就引入了方法3，就是提前尝试，锁定这两条记录的资源，
















